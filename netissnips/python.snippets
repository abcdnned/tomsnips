#dcd field define start
snippet fielddefine "dcd field define line" b
def fielddefine(index,l,fn,record=True,charset='Encoding.CHARSET'):
    if not record:
        return '{{ {{ {}, null, {}, {} }}, {{ "", null, false, "{}" }} }},\n'.format(index,l,charset,fn)
    return '{{ {{ {}, null, {}, {} }}, {{ "", ValueType.STRING, false, "{}" }} }},\n'.format(index,l,charset,fn)
endsnippet

snippet definecloser "dcd field define closer" b
def definecloser():
    return '};\n'
endsnippet

snippet definehead "dcd field define header" b
def definehead(name):
    return 'static final Object[][][] {} = {{ \n'.format(name)
endsnippet

snippet definemap "dcd field define regesiter to map" b
def defineregmap(mapname,regname):
    return '{}.put("{}", new Object[][][] {{\n'.format(mapname,regname)
endsnippet

snippet staticfield "dcd field static define" b
def staticfield(fieldname,defname):
	return 'private static final DecodeField[] {} = new DecodeField[{}.length];\n'.format(fieldname,defname)
endsnippet

snippet definebuild "dcd field build" b
def fieldbuild(fieldname,defname):
	return 'BankFieldFactory.buildFields({},{})\n'.format(fieldname,defname)
endsnippet

snippet staticfieldreg "dcd field static field reg to map" b
def defineregmap(mapname,regname,fieldname):
    return '{}.put("{}", {})\n'.format(mapname,regname,fieldname)
endsnippet

snippet dcdgendef "dcd generate field define" b
#!/usr/bin/env python
# -*- coding: utf-8 -*-

from os.path import join

def getin(content,start,end):
    s=content.find(start)
    e=content.find(end,s+len(start))
    return content[s+len(start):e]

def checkdefine(line):
    return '_RRA' in line

def checkfield(line):
    return '<field' in line

def fielddefine(index,l,fn,record=True,charset='Encoding.CHARSET'):
    if not record:
        return '{{ {{ {}, null, {}, {} }}, {{ "", null, false, "{}" }} }},\n'.format(index,l,charset,fn)
    return '{{ {{ {}, null, {}, {} }}, {{ "", ValueType.STRING, false, "{}" }} }},\n'.format(index,l,charset,fn)

def definehead(name):
    return ' private static final Object[][][] {} = {{ \n'.format(name)

def definecloser():
    return '};\n'

def staticfield(fieldname,defname):
    return 'private static final DecodeField[] {} = new DecodeField[{}.length];\n'.format(fieldname,defname)

def fieldbuild(fieldname,defname):
    return 'BankFieldFactory.buildFields({},{});\n'.format(fieldname,defname)

def defineregmap(mapname,regname,fieldname):
    return '{}.put("{}", {})\n'.format(mapname,regname,fieldname)

def searchline(lines,s,pattern,limit):
    for i in range(limit):
        if pattern in lines[s+i]:
            return s+i
    return -1

i=open('${1:input}')
lines=i.readlines()

defs=''
fld=''
build=''

firstflag=True
index=0

for ln,line in enumerate(lines):
    if checkdefine(line):
        if firstflag:
            firstflag=False
        else:
            defs+=definecloser()
        index=0
        name=${2:getname}
        defname='DEF_'+name
        fieldname='FIELD_'+name
        defs+=definehead(defname)
        fld+=staticfield(fieldname,defname)
        build+=fieldbuild(fieldname,defname)
    elif checkfield(line):
        ${3:fielddefine}
        index+=1

defs+=definecloser()
        

i.close()
o=open('${4:output}','w')
o.write(defs)
o.write(fld)
o.write('static {\n')
o.write(build)
o.write('}\n')
o.flush()
o.close()

endsnippet

snippet gmd "generate multi define files" b
#!/usr/bin/env python
# -*- coding: utf-8 -*-

from os.path import join

def getin(content,start,end):
    s=content.find(start)
    e=content.find(end,s+len(start))
    return content[s+len(start):e]

def getnumin(content):
    return ''.join(c for c in content if c.isdigit())

def hasdefname(line):
    pass

def checkdefine(line):
    pass

def checkfield(line):
    pass

def deffldmap(mapn):
    return 'static final Map<String,DecodeField[]> {} =new HashMap<String,DecodeField[]>();\n'.format(mapn)

def putfld(mapn,key,consn,fldn):
    return '{}.put("{}",{}.{});\n'.format(mapn,key,consn,fldn)

def fielddefine(index,l,fn,record=True,charset='Encoding.CHARSET'):
    if not record:
        return '{{ {{ {}, null, {}, {} }}, {{ "", null, false, "{}" }} }},\n'.format(index,l,charset,fn)
    return '{{ {{ {}, null, {}, {} }}, {{ "", ValueType.STRING, false, "{}" }} }},\n'.format(index,l,charset,fn)

def definehead(name):
    return ' private static final Object[][][] {} = {{ \n'.format(name)

def definecloser():
    return '};\n'

def staticfield(fieldname,defname):
    return 'static final DecodeField[] {} = new DecodeField[{}.length];\n'.format(fieldname,defname)

def fieldbuild(fieldname,defname):
    return 'BankFieldFactory.buildFields({},{});\n'.format(fieldname,defname)

def defineregmap(mapname,regname,fieldname):
    return '{}.put("{}", {})\n'.format(mapname,regname,fieldname)

def searchline(lines,s,pattern,limit):
    for i in range(limit):
        if pattern in lines[s+i]:
            return s+i
    return -1

def getname(line):
    pass

def gendeffilehead(pkg,deffn):
    return 'package cn.com.netis.dcd.parser.decoder.bank.{};\nimport cn.com.netis.dcd.parser.huygens.field.DecodeField;\nimport cn.com.netis.dcd.parser.huygens.field.Encoding;\nimport cn.com.netis.dcd.parser.huygens.field.bank.BankFieldFactory;\nimport cn.com.netis.dp.commons.lang.ValueType;\n\npublic class {} {{\n\n'.format(pkg,deffn)


def genmaphead(pkg,classn):
    return 'package cn.com.netis.dcd.parser.decoder.bank.{};\n\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport cn.com.netis.dcd.parser.huygens.field.DecodeField;\n\npublic class {} {{\n'.format(pkg,classn)

def writedefs(defs,fld,build,f):
    o=open(f,'w')
    o.write(gendeffilehead('${5:pkgname}',deffn+str(n)))
    o.write(defs)
    o.write(fld)
    o.write('static {\n')
    o.write(build)
    o.write('}\n')
    o.write('}\n')
    o.flush()
    o.close()

def writereg(n,regs,f,mapdef):
    o=open(f,'w')
    o.write(genmaphead('$5','${4:name of java fields map file}'))
    o.write(mapdef)
    o.write('static {\n')
    o.write(regs)
    o.write('}\n')
    o.write('}\n')
    o.flush()
    o.close()

i=open('${1:path of intput file}')
lines=i.readlines()

rraflag=0

defs=''
fld=''
build=''
regs=''

deffn='${2:preffix of define java file}'

firstflag=True
index=0
name=''

defined=0
limit=55
n=1



outputws='${3:output file work space}'
mapdefn='$4'

for ln,line in enumerate(lines):
    if hasdefname(line):
        name=getname(line)
        rraflag=0
    else:
        if checkdefine(line):
            if firstflag:
                firstflag=False
            else:
                defs+=definecloser()
            if defined>=limit:
                writedefs(defs,fld,build,'{}{}{}.java'.format(outputws,deffn,n))
                defs=''
                fld=''
                build=''
                defined=0
                n+=1
            index=0
			#figure out name of defines, fields and build statement
            #rra='REQ_' if rraflag==0 else 'RESP_'
            #rraflag=(rraflag+1)%2
            #defname='DEF_'+rra+name
            #fieldname='FIELD_'+rra+name
			defname=
			fieldname=
            defs+=definehead(defname)
            fld+=staticfield(fieldname,defname)
            build+=fieldbuild(fieldname,defname)
            regs+=putfld('FIELD_MAP',name+rra[:-1].lower(),'{}{}'.format(deffn,n),fieldname)
            defined+=1
        if checkfield(line):
			#figure out what's the name of field and the length of this field
            fn=
            length=
            defs+=fielddefine(index,length,fn)
            index+=1

if defined>0:
    defs+=definecloser()
    writedefs(defs,fld,build,'{}{}{}.java'.format(outputws,deffn,n))

i.close()

writereg(n,regs,'{}{}.java'.format(outputws,mapdefn),deffldmap('FIELD_MAP'))


endsnippet
